
<!DOCTYPE html>
<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">




<title>Golang杂物柜 | 自在生活</title>

<link rel="stylesheet" href="https://www.at719.com/css/styles.css">

<link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/5.8.1/css/all.css" 
 crossorigin="anonymous">
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js" ></script>


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/zenburn.min.css"  />
<script src="https://cdn.bootcss.com/highlight.js/9.15.6/highlight.min.js"  crossorigin="anonymous" ></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="https://www.at719.com/js/highlight.js"></script>




<body>

<div class="toc" id="toc_container">
    <div class="toc-content">
        <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#数组">数组</a>
<ul>
<li><a href="#声明数组">声明数组</a></li>
<li><a href="#初始化数组">初始化数组</a></li>
<li><a href="#遍历数组">遍历数组</a></li>
</ul></li>
<li><a href="#切片">切片</a></li>
<li><a href="#结构体">结构体</a>
<ul>
<li><a href="#匿名字段">匿名字段</a></li>
</ul></li>
<li><a href="#channel">channel</a>
<ul>
<li><a href="#创建管道">创建管道</a></li>
<li><a href="#向管道写入数据">向管道写入数据</a></li>
<li><a href="#从管道中读取数据">从管道中读取数据</a></li>
<li><a href="#缓冲通道">缓冲通道</a></li>
</ul></li>
<li><a href="#内置函数">内置函数</a>
<ul>
<li><a href="#make">make</a></li>
<li><a href="#len">len</a></li>
<li><a href="#cap">cap</a></li>
<li><a href="#append">append</a></li>
<li><a href="#copy">copy</a></li>
<li><a href="#delete">delete</a></li>
<li><a href="#panic">panic</a></li>
<li><a href="#recover">recover</a></li>
<li><a href="#close">close</a></li>
<li><a href="#complex">complex</a></li>
<li><a href="#real">real</a></li>
<li><a href="#image">image</a></li>
<li><a href="#print">Print</a></li>
<li><a href="#printin">Printin</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
    </div>
</div>

<div class="container">
    <nav class="navbar level">
      <div class="navbar-brand">
          <a class="nav-item" href="https://www.at719.com"><h1 class="title is-3">自在生活</h1></a>
      </div>           
      <div class="navbar-menu has-text-centered is-active">
          <div class="navbar-end is-centered">
              
                <a href="https://github.com/junlv/">
                  <span class="icon">
                    <i class="fab fa-github"></i>
                  </span>
                </a>
              
                <a href="https://www.at719.com">
                  <span class="icon">
                    <i class="fa fa-home"></i>
                  </span>
                </a>
              
                <a href="https://github.com/junlv/junlv.github.io/issues">
                  <span class="icon">
                    <i class="fa fa-question-circle"></i>
                  </span>
                </a>
              
           </div>
      </div>
    </nav>
  </div>
<div class="container">
  <h2 class="subtitle is-6">April 10, 2019
      
      
         &nbsp;&nbsp;<a href="https://www.at719.com/tags/golang">golang</a> 
      
    
  </h2>
  <h1 class="subtitle is-size-4-mobile is-size-3-desktop">Golang杂物柜</h1>
  <div class="content">
    

<h2 id="数组">数组</h2>

<h3 id="声明数组">声明数组</h3>

<pre><code class="language-golang">var arr [3]string
</code></pre>

<h3 id="初始化数组">初始化数组</h3>

<pre><code class="language-golang">var arr= [3]string{&quot;i&quot;，&quot;love&quot;,&quot;you&quot;}
或者
var arr= [...]string{&quot;i&quot;，&quot;love&quot;,&quot;you&quot;}
</code></pre>

<h3 id="遍历数组">遍历数组</h3>

<pre><code class="language-golang">
var arr= [...]string{&quot;i&quot;，&quot;love&quot;,&quot;you&quot;}
for k,v := range arr {

}
</code></pre>

<h2 id="切片">切片</h2>

<h2 id="结构体">结构体</h2>

<p>不同结构体变量的字段是独立，互不影响，一个结构体变量字段的更改，不影响另外一个, 结构体是值类型</p>

<p>Golang 继承是通过匿名字段来实现。Golang 面向对象(OOP)很优雅，OOP 本身就是语言类型系统(typesystem)的一部分，通过接口 (interface)关联，耦合性低，也非常灵活。</p>

<ul>
<li>继承</li>
</ul>

<p>在 Golang 中，如果一个 struct 嵌套了另一个匿名结构体，那么这个结构体可以直接访 问匿名结构体的字段和方法，从而实现了继承特性。一般在 golang 中不叫继承而叫组合</p>

<blockquote>
<p>当我们嵌入一个类型，这个类型的方法就变成了外部类型的方法，但是当它被调用时，方法的接受者是内部类型(嵌入类型)，而非外部类型。— Effective Go</p>
</blockquote>

<h3 id="匿名字段">匿名字段</h3>

<pre><code class="language-Go">
type Person struct {
	Name string
	Age  int
}

func (person *Person) info() string {
	return fmt.Sprintf(&quot;%s  age is %d&quot;, person.Name, person.Age)
}

func (person Person) feature() string {
	return fmt.Sprintf(&quot;%s can walk can talk &quot;, person.Name)
}

type Student struct {
	*Person
	Score int
}

func (person Person) skill() string {
	return fmt.Sprintf(&quot;%s can walk can talk &quot;, person.Name)
}

func main() {

	human1 := &amp;Person{
		Name: &quot;tom&quot;,
		Age:  18,
	}
	fmt.Println(human1.info())
	fmt.Println(human1.feature())

	human2 := &amp;Student{
		Person: &amp;Person{
			Name: &quot;lisa&quot;,
			Age:  17,
		},
		Score: 100,
	}
	fmt.Println(human2.info())
	fmt.Println(human2.feature())
}
</code></pre>

<h2 id="channel">channel</h2>

<ol>
<li><p>channle 本质就是一个数据结构-队列【FIFO : first in first out】</p></li>

<li><p>c 多 goroutine 访问 hannle 时，不需要加锁, channel 本身就是线程安全</p></li>

<li><p>channel 有类型的，一个 string 的 channel 只能存放 string 类型数据。</p></li>

<li><p>channel 是引用类型,必须初始化才能写入数据, 即 make 后才能使用</p></li>

<li><p>channle 的数据放满后，就不能再放入了</p></li>

<li><p>使用内置函数 close 可以关闭 channel, 当 channel 关闭后，就不能再向 channel 写数据了，但是仍然 可以从该 channel 读取数据</p></li>
</ol>

<h3 id="创建管道">创建管道</h3>

<pre><code class="language-Go">var intChan chan int
intChan = make(chan int, 3)

// 声明只写
var chan2 chan&lt;- int
chan2 = make(chan int, 3)
chan2&lt;-1

// 声明只读
var chan3 &lt;-chan int
chan3 = make(chan int, 3)
num2 := &lt;-chan3
</code></pre>

<h3 id="向管道写入数据">向管道写入数据</h3>

<p>intChan&lt;- 10</p>

<h3 id="从管道中读取数据">从管道中读取数据</h3>

<p>var num2 int
num2 = &lt;-intChan</p>

<h3 id="缓冲通道">缓冲通道</h3>

<p>Happens before
1 发送操作会使通道复制被发送的元素。若因通道的缓冲空间已满而无法立即复制，
则阻塞进行发送操作的 goroutine。复制的目的地址有两种。
当通道已空且有接收方在等待元素值时，它会是最早等待的那个接收方持有的内存地址，否则会是
通道持有的缓冲中的内存地址。</p>

<p>2 接收操作会使通道给出一个已发给它的元素值的副本，若因通道的缓冲空间已空而无法立即给出
，则阻塞进行接收操作的 goroutine。一般情况下，接收方会从通道持有的缓冲中得到元素值。</p>

<p>3 对于同一个元素值来说，把它发送给某个通道的操作，一定会在从该通道接收它的操作完成之前完成。换句话
说。在通道完全复制一个元素之前，任何 goroutine 都不可能从它那里接收到这个元素的副本。</p>

<h2 id="内置函数">内置函数</h2>

<h3 id="make">make</h3>

<h3 id="len">len</h3>

<h3 id="cap">cap</h3>

<h3 id="append">append</h3>

<h3 id="copy">copy</h3>

<h3 id="delete">delete</h3>

<h3 id="panic">panic</h3>

<h3 id="recover">recover</h3>

<h3 id="close">close</h3>

<h3 id="complex">complex</h3>

<h3 id="real">real</h3>

<h3 id="image">image</h3>

<h3 id="print">Print</h3>

<h3 id="printin">Printin</h3>

  </div>
</div>

<div class="container has-text-centered">
 
</div>

<div class="container has-text-centered">
  
</div>
<section class="section">
  <div class="container has-text-centered">
    
  </div>
</section>
<script src="/js/zen.js"></script>
</body>
</html>


